# ---------------------------------------------------------------------------
# 0.  Packages: Nginx + Certbot
# ---------------------------------------------------------------------------
- name: Ensure Nginx and Certbot packages are present
  ansible.builtin.apt:
    name:
      - nginx
      - certbot
      - python3-certbot-nginx
    state: present
    update_cache: yes

# ---------------------------------------------------------------------------
# 1.  Temporary HTTP-only proxy (for ACME HTTP-01 challenge)
# ---------------------------------------------------------------------------
- name: Install temporary HTTP-only vhost
  ansible.builtin.copy:
    dest: /etc/nginx/sites-available/jenkins-temp.conf
    mode: "0644"
    content: |
      server {
          listen 80 default_server;
          server_name _;
          location / {
              proxy_pass          http://127.0.0.1:8080;
              proxy_set_header    Host              $host;
              proxy_set_header    X-Real-IP         $remote_addr;
              proxy_set_header    X-Forwarded-For   $proxy_add_x_forwarded_for;
              proxy_set_header    X-Forwarded-Proto $scheme;
              proxy_buffering     off;
          }
      }
  notify: reload nginx

- name: Enable temporary vhost & remove distro default
  ansible.builtin.file:
    src:  /etc/nginx/sites-available/jenkins-temp.conf
    dest: /etc/nginx/sites-enabled/jenkins-temp.conf
    state: link
  notify: reload nginx

- name: Ensure default “welcome” vhost is absent
  ansible.builtin.file:
    path: /etc/nginx/sites-enabled/default
    state: absent
  notify: reload nginx

# ---------------------------------------------------------------------------
# 2.  Try every public suffix until Certbot succeeds
# ---------------------------------------------------------------------------
- name: Initialise success flag
  set_fact:
    cert_obtained: false
    jenkins_live_domain: ""

- name: Run Certbot for each candidate domain
  shell: |
    DOMAIN="jenkins.{{ jenkins_public_ip }}.{{ item }}"
    if [ ! -f "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" ]; then
      certbot --nginx --non-interactive --agree-tos \
              --email {{ letsencrypt_email }} \
              --redirect \
              -d "${DOMAIN}"
    fi
  args:
    executable: /bin/bash            # makes the if-statement work
  register: certbot_attempts          # collects *all* loop results
  failed_when: false                  # don’t abort the play on errors
  loop: "{{ public_suffixes }}"
  loop_control:
    label: "jenkins.{{ jenkins_public_ip }}.{{ item }}"
  notify: reload nginx

- name: Record winning domain (if any)
  set_fact:
    cert_obtained: true
    jenkins_live_domain: "{{ item.item | ternary('jenkins.' ~ jenkins_public_ip ~ '.' ~ item.item, '') }}"
  when: item.rc is defined and item.rc == 0
  loop: "{{ certbot_attempts.results }}"
  loop_control:
    label: "{{ item.item }}"

- name: Abort when no certificate could be obtained
  fail:
    msg: |
      Could not obtain a Let’s Encrypt certificate after trying:
      {{ public_suffixes | map('regex_replace', '(.*)', 'jenkins.' ~ jenkins_public_ip ~ '.\\1') | join(', ') }}
  when: not cert_obtained

# ---------------------------------------------------------------------------
# 3.  Permanent HTTP→HTTPS & HTTPS proxy vhosts
# ---------------------------------------------------------------------------
- name: Install permanent HTTP→HTTPS redirect vhost
  ansible.builtin.copy:
    dest: /etc/nginx/sites-available/jenkins-http.conf
    mode: "0644"
    content: |
      server {
          listen 80;
          server_name {{ jenkins_live_domain }};
          return 301 https://$host$request_uri;
      }
  notify: reload nginx

- name: Install permanent HTTPS proxy vhost
  ansible.builtin.copy:
    dest: /etc/nginx/sites-available/jenkins-ssl.conf
    mode: "0644"
    content: |
      server {
          listen 443 ssl http2;
          server_name {{ jenkins_live_domain }};

          ssl_certificate     /etc/letsencrypt/live/{{ jenkins_live_domain }}/fullchain.pem;
          ssl_certificate_key /etc/letsencrypt/live/{{ jenkins_live_domain }}/privkey.pem;

          ssl_protocols       TLSv1.2 TLSv1.3;
          ssl_session_cache   shared:SSL:10m;
          ssl_prefer_server_ciphers on;

          location / {
              proxy_pass          http://127.0.0.1:8080;
              proxy_set_header    Host              $host;
              proxy_set_header    X-Real-IP         $remote_addr;
              proxy_set_header    X-Forwarded-For   $proxy_add_x_forwarded_for;
              proxy_set_header    X-Forwarded-Proto $scheme;
              proxy_buffering     off;
          }
      }
  notify: reload nginx

- name: Enable permanent vhosts & remove temporary one
  block:
    - name: Enable HTTP redirect vhost
      ansible.builtin.file:
        src:  /etc/nginx/sites-available/jenkins-http.conf
        dest: /etc/nginx/sites-enabled/jenkins-http.conf
        state: link

    - name: Enable HTTPS proxy vhost
      ansible.builtin.file:
        src:  /etc/nginx/sites-available/jenkins-ssl.conf
        dest: /etc/nginx/sites-enabled/jenkins-ssl.conf
        state: link

    - name: Remove temporary vhost symlink
      ansible.builtin.file:
        path: /etc/nginx/sites-enabled/jenkins-temp.conf
        state: absent

    - name: Remove temporary vhost file
      ansible.builtin.file:
        path: /etc/nginx/sites-available/jenkins-temp.conf
        state: absent
  notify: reload nginx

# ---------------------------------------------------------------------------
# 4.  Make sure certbot renewals run automatically
# ---------------------------------------------------------------------------
- name: Ensure certbot.timer is enabled and started
  ansible.builtin.systemd:
    name: certbot.timer
    enabled: true
    state: started

# ---------------------------------------------------------------------------
# 5.  Lock Jenkins to localhost
# ---------------------------------------------------------------------------
- name: Bind Jenkins HTTP listener to 127.0.0.1
  ansible.builtin.lineinfile:
    path: /etc/default/jenkins
    regexp: '^HTTP_HOST='
    line: 'HTTP_HOST=127.0.0.1'
    state: present
  notify: restart jenkins

# ---------------------------------------------------------------------------
# 6.  Read admin password & wait until Jenkins is up
# ---------------------------------------------------------------------------
- name: Read initial admin password
  ansible.builtin.slurp:
    src: /var/lib/jenkins/secrets/initialAdminPassword
  register: initial_pw
  run_once: true

- name: Cache admin password fact
  ansible.builtin.set_fact:
    jenkins_admin_password: "{{ initial_pw.content | b64decode | trim }}"

- name: Wait for Jenkins login page to respond
  ansible.builtin.uri:
    url: "http://localhost:8080/login"
    status_code: 200
  register: jstat
  retries: 10
  delay: 15
  until: jstat.status == 200

- name: Write Groovy script to create Jenkins user
  copy:
    dest: /tmp/create_user.groovy
    content: |
      import jenkins.model.*
      import hudson.security.*

      def instance = Jenkins.getInstance()
      def hudsonRealm = instance.getSecurityRealm()

      hudsonRealm.createAccount("{{ jenkins_username }}", "{{ jenkins_password }}")
      instance.save()

- name: Download Jenkins CLI jar
  get_url:
    url: "http://localhost:8080/jnlpJars/jenkins-cli.jar"
    dest: "/tmp/jenkins-cli.jar"
    mode: '0755'

- name: Create Jenkins user via CLI using initial admin password
  shell: >
    java -jar /tmp/jenkins-cli.jar
    -s http://localhost:8080
    -auth admin:{{ jenkins_admin_password }}
    groovy = < /tmp/create_user.groovy
  args:
    executable: /bin/bash


- name: Write Groovy script to generate Jenkins API token
  copy:
    dest: /tmp/create_token.groovy
    content: |
      import jenkins.model.*
      import hudson.model.*
      import jenkins.security.*
      import hudson.security.*
      import com.cloudbees.plugins.credentials.*
      import com.cloudbees.plugins.credentials.domains.*
      import jenkins.security.apitoken.*

      def user = User.get('{{ jenkins_username }}', false)
      def apiTokenProperty = user.getProperty(ApiTokenProperty.class)

      def result = apiTokenProperty.tokenStore.generateNewToken('{{ jenkins_token_name }}')
      user.save()
      println(result.plainValue)

- name: Generate API token via Jenkins CLI
  shell: >
    java -jar /tmp/jenkins-cli.jar
    -s http://localhost:8080
    -auth {{ jenkins_username }}:{{ jenkins_password }}
    groovy = < /tmp/create_token.groovy
  args:
    executable: /bin/bash
  register: jenkins_token_output
  changed_when: true

- name: Set API token as fact
  set_fact:
    jenkins_api_token: "{{ jenkins_token_output.stdout | trim }}"

- name: Get Git credentials from TF Vault
  uri:
    url: "{{ remote_vault_address }}/v1/secret/data/git_credentials"
    method: GET
    headers:
      X-Vault-Token: "{{ remote_vault_token }}"
    return_content: yes
  register: vault_response

- name: Set credentials as fact for use in next task
  ansible.builtin.set_fact:
    git_username: "{{ vault_response.json.data.data.git_username }}"
    git_password: "{{ vault_response.json.data.data.git_password }}"

- name: Get Jenkins crumb
  uri:
    url: "https://{{ jenkins_live_domain }}/crumbIssuer/api/json"
    method: GET
    user: "{{ jenkins_username }}"
    password: "{{ jenkins_api_token }}"
    force_basic_auth: yes
  register: jenkins_crumb

- name: Execute Groovy script via REST API
  uri:
    url: "https://{{ jenkins_live_domain }}/scriptText"
    method: POST
    user: "{{ jenkins_username }}"
    password: "{{ jenkins_api_token }}"
    force_basic_auth: yes
    headers:
      Jenkins-Crumb: "{{ jenkins_crumb.json.crumb }}"
    body_format: form-urlencoded
    body:
      script: |
        import com.cloudbees.plugins.credentials.*
        import com.cloudbees.plugins.credentials.domains.*
        import com.cloudbees.plugins.credentials.impl.*
        import jenkins.model.*

        def username = "{{ git_username }}"
        def password = "{{ git_password }}"
        def description = "Git credentials from Vault"
        def id = "git-credentials"

        def credentials = new UsernamePasswordCredentialsImpl(
          CredentialsScope.GLOBAL, id, description, username, password
        )

        SystemCredentialsProvider.getInstance().getStore().addCredentials(Domain.global(), credentials)
        println("Credentials created successfully")

# ---------------------------------------------------------------------------
# 7.  Drop Groovy init script
# ---------------------------------------------------------------------------
- name: Ensure init.groovy.d exists
  ansible.builtin.file:
    path: /var/lib/jenkins/init.groovy.d
    state: directory
    owner: jenkins
    group: jenkins
    mode: "0755"

- name: Deploy OIDC initialisation script
  ansible.builtin.copy:
    src: jenkins/oidc-init.groovy
    dest: /var/lib/jenkins/init.groovy.d/01-oidc.groovy
    owner: jenkins
    group: jenkins
    mode: "0644"
  notify: restart jenkins

# ---------------------------------------------------------------------------
# 8.  Enhanced Credential Management
# ---------------------------------------------------------------------------
- name: Get all credentials from Vault for Jenkins
  uri:
    url: "{{ remote_vault_address }}/v1/secret/data/{{ item }}"
    method: GET
    headers:
      X-Vault-Token: "{{ remote_vault_token }}"
    return_content: yes
  register: vault_credentials
  loop:
    - git_credentials
    - aws
    - velero
    - jenkins
    - docker_credentials
  no_log: true
  loop_control:
    label: "{{ item }}"

- name: Set credential facts from Vault
  no_log: true
  set_fact:
    git_username: "{{ (vault_credentials.results | selectattr('item', 'equalto', 'git_credentials') | first).json.data.data.git_username }}"
    git_password: "{{ (vault_credentials.results | selectattr('item', 'equalto', 'git_credentials') | first).json.data.data.git_password }}"
    aws_access_key: "{{ (vault_credentials.results | selectattr('item', 'equalto', 'aws') | first).json.data.data.access_key }}"
    aws_secret_key: "{{ (vault_credentials.results | selectattr('item', 'equalto', 'aws') | first).json.data.data.secret_key }}"
    backup_bucket: "{{ (vault_credentials.results | selectattr('item', 'equalto', 'velero') | first).json.data.data.bucket_name }}"
    backup_bucket_region: "{{ (vault_credentials.results | selectattr('item', 'equalto', 'velero') | first).json.data.data.region }}"
    docker_username: "{{ (vault_credentials.results | selectattr('item', 'equalto', 'docker_credentials') | first).json.data.data.docker_username }}"
    docker_password: "{{ (vault_credentials.results | selectattr('item', 'equalto', 'docker_credentials') | first).json.data.data.docker_password }}"

- name: Read SSH private key for credentials
  slurp:
    src: "{{ ssh_key_path | default('{{ playbook_dir }}/../k8s-cluster.pem') }}"
  delegate_to: localhost
  register: ssh_key_content
  become: false
  when: ssh_key_path is defined
  no_log: true

- name: Create comprehensive Jenkins credentials via Groovy
  uri:
    url: "https://{{ jenkins_live_domain }}/scriptText"
    method: POST
    user: "{{ jenkins_username }}"
    password: "{{ jenkins_api_token }}"
    force_basic_auth: yes
    headers:
      Jenkins-Crumb: "{{ jenkins_crumb.json.crumb }}"
    body_format: form-urlencoded
    body:
      script: |
        {{ lookup('file', 'files/jenkins/create-credentials.groovy') | 
           replace('${GIT_USERNAME}', git_username) |
           replace('${GIT_PASSWORD}', git_password) |
           replace('${DOCKER_USERNAME}', docker_username | default('your-docker-user')) |
           replace('${DOCKER_PASSWORD}', docker_password | default('your-docker-pass')) |
           replace('${AWS_ACCESS_KEY}', aws_access_key) |
           replace('${AWS_SECRET_KEY}', aws_secret_key) |
           replace('${BACKUP_BUCKET}', backup_bucket) |
           replace('${BACKUP_BUCKET_REGION}', backup_bucket_region) |
           replace('${SSH_PRIVATE_KEY}', ssh_key_content.content | b64decode) }}
    status_code: [200]
  no_log: true
  register: credentials_result

- name: Read main kubeconfig file
  slurp:
    src: "{{ kubeconfig_main_path }}"
  register: main_kubeconfig_file
  delegate_to: localhost
  become: false
  no_log: true
  when: kubeconfig_main_path is defined

- name: Load kubeconfig file
  set_fact:
    kubeconfig_data: "{{ lookup('file', kubeconfig_agent_path) | from_yaml }}"

- name: Extract Kubernetes server URL
  set_fact:
    k8s_server_url: "{{ kubeconfig_data.clusters[0].cluster.server }}"

- name: Read Jenkins agent kubeconfig file  
  slurp:
    src: "{{ kubeconfig_agent_path }}"
  register: agent_kubeconfig_file
  delegate_to: localhost
  become: false
  no_log: true
  when: kubeconfig_agent_path is defined

- name: Load kubeconfig file
  delegate_to: localhost
  become: false
  no_log: true
  set_fact:
    kubeconfig_data: "{{ lookup('file', kubeconfig_agent_path) | from_yaml }}"

- name: Extract Kubernetes server URL
  set_fact:
    k8s_server_url: "{{ kubeconfig_data.clusters[0].cluster.server }}"


- name: Add Kubeconfig credentials to Jenkins
  uri:
    url: "https://{{ jenkins_live_domain }}/scriptText"
    method: POST
    user: "{{ jenkins_username }}"
    password: "{{ jenkins_api_token }}"
    force_basic_auth: yes
    headers:
      Jenkins-Crumb: "{{ jenkins_crumb.json.crumb }}"
    body_format: form-urlencoded
    body:
      script: |
        {{ lookup('file', 'files/jenkins/add-kubeconfig.groovy') |
           replace('${MAIN_KUBECONFIG_FILENAME}', 'kubeconfig-' + ansible_default_ipv4.address + '.yaml') |
           replace('${MAIN_KUBECONFIG_CONTENT}', main_kubeconfig_file.content | b64decode) |
           replace('${AGENT_KUBECONFIG_CONTENT}', agent_kubeconfig_file.content | b64decode) }}
    status_code: [200]
  no_log: true
  when: main_kubeconfig_file is defined and agent_kubeconfig_file is defined

# ---------------------------------------------------------------------------
# 9.  Configure Kubernetes Cloud
# ---------------------------------------------------------------------------

- name: Get Jenkins private IP for tunnel configuration
  set_fact:
    jenkins_tunnel_url: "{{ jenkins_private_ip }}:50000"

- name: Configure Kubernetes Cloud in Jenkins
  uri:
    url: "https://{{ jenkins_live_domain }}/scriptText"
    method: POST
    user: "{{ jenkins_username }}"
    password: "{{ jenkins_api_token }}"
    force_basic_auth: yes
    headers:
      Jenkins-Crumb: "{{ jenkins_crumb.json.crumb }}"
    body_format: form-urlencoded
    body:
      script: |
        {{ lookup('file', 'files/jenkins/configure-k8s-cloud.groovy') |
           replace('${CLOUD_NAME}', 'k8s-automated-dr') |
           replace('${K8S_SERVER_URL}', '{{ k8s_server_url }}') |
           replace('${K8S_NAMESPACE}', 'jenkins') |
           replace('${JENKINS_URL}', 'https://{{ jenkins_live_domain }}') |
           replace('${JENKINS_TUNNEL}', '{{ jenkins_tunnel_url }}') |
           replace('${CREDENTIALS_ID}', 'k8s-jenkins-agent') |
           replace('${CONTAINER_CAP}', '10') }}
    status_code: [200]
  register: k8s_cloud_config
  when: k8s_server_url is defined
